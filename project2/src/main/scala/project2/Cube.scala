package project2

import java.util

import scala.collection.mutable.Queue
import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.ListBuffer
import scala.collection.mutable.LinkedList
import java.util.Scanner

/**
 * Created by chelsea on 9/17/15.
 */

/**
 * Driver class: Build, traverse, print linkage
 */
/*class CubeDriver {
  def main(args: Array[String]) = {
    var sideNodes = 3
    val cube = new Cube()
    cube.build(cube.generateCubeGraph(sideNodes))

    System.out.println("Node execution order: ")
    cube.BFT()

    System.out.println("Nodes links:")
    cube.printAL()

    System.out.println("Nodes on Layers:")
    cube.printLayers(sideNodes)
  }
}*/

/**
 * Cube creator
 */
class Cube {

  // Adjacency list (Hold node's neighbors)
  //var al = new ArrayBuffer[Int][Int]
  type Row = ArrayBuffer[Int]
  var myRowOfInts = new Row
  val al = new ArrayBuffer[Row]

  // Degree array (Count how many neighbor per node)
  var dl = new ArrayBuffer[Int]

  var NODES: Int = 0
  var EDGES: Int = 0
  var MAX_LINKS: Int = 6

  var node1: Int = 0
  var node2: Int = 0

  /**
   * Create the links between nodes based on the input generated by generateCubeGraph() method
   */
  def build(input: String) = {
    //println("@@@@@@@" + input)
    //Scanner scan = new Scanner(input)
    var scan: Scanner = new Scanner(input)
    NODES = scan.nextInt()
    EDGES = scan.nextInt()
    println("Nodes: " + NODES + "    Edges: " + EDGES)

    al += ArrayBuffer(NODES,MAX_LINKS)
    dl ++= ArrayBuffer(NODES)

    var a = Array.ofDim[Int](EDGES,2)

    //al = new ArrayBuffer(NODES)(MAX_LINKS)
    //dl = new ArrayBuffer(NODES)

    for (i <- 0 to EDGES-1) {
      node1 = scan.nextInt()
      node2 = scan.nextInt()

      //println("Node1: " + node1 + "   Node2: " + node2)

      //al(i)(0) = node1
      //al(i)(1) = node2

      a(i)(0) = node1
      a(i)(1) = node2

      /*var node1Neighbors = dl(node1)
      var node1Neigh = node1Neighbors + 1
      var node2Neighbors = dl(node2)
      var node2Neigh = node2Neighbors + 1

      al(node1)(node1Neigh) = node2
      al(node2)(node2Neigh) = node1*/
    }

    for (i <- 0 to EDGES-1) {
      println(a(i)(0) + ",  " + a(i)(1))
    }
  }

  /**
   * Traverse using Breadth first traversal method
   * Plug the middle node in a queue, then poll it and put it's neighbor, then poll each neighbor and put their neighbors if not visited already
   */
  def BFT() = {
    val visited = new ArrayBuffer[Int](NODES)
    var q = Queue[Int]()
    //var l = new ListBuffer[Int]
    //Queue<Integer> q = new LinkedList<Integer>();
    //q = new ListBuffer[Int]
    //Queue[Int] qu = new ListBuffer[Int]()
    var VISITED: Int = 1

    // Plug the center node
    var middle = NODES/2
    q.enqueue(middle)
    visited(middle) = VISITED

    while (!q.isEmpty) {
      var polledNode = q.dequeue()
      System.out.print(polledNode + " ")

      for (i <- 0 to dl(polledNode)) {
        var neighbor = al(polledNode)(i)

        if (visited(neighbor) != VISITED) {
          q.enqueue(neighbor)
          visited(neighbor) = VISITED
        }
      }
    }
    System.out.println("\n");
  }

  /**
   * Input generator for a cube
   */
  def generateCubeGraph(n: Int): String = {
    var SIDE = n   // Number of nodes in one side of the cube
    var links = ""  // Holds the final output
    var link = 0    // Counts the number of links

    for (row <- 0 to SIDE) {
      for (col <- 0 to SIDE) {
        for (depth <- 0 to SIDE) {
          var current = depth + (col * SIDE) + (row * SIDE * SIDE)

          // If not last depth
          if(depth != SIDE-1) {
            //links += String.format("%d %d\n", current, current+1)
            links += "%d %d\n".format(current, current+1)
            link = link + 1
          }

          // If not last col
          if(col != SIDE-1) {
            //links += String.format("%d %d\n", current, current+SIDE)
            links += "%d %d\n".format(current, current+SIDE)
            link = link + 1
          }

          // If not last row
          if(row != SIDE-1) {
            //links += String.format("%d %d\n", current, current+(SIDE*SIDE))
            links += "%d %d\n".format(current, current+(SIDE*SIDE))
            link = link + 1
          }
        }
      }
    }
    // return #Nodes, #Edges, links ...
    //String.format("%d %d\n%s", SIDE*SIDE*SIDE, link, links)
    "%d %d\n%s".format(SIDE*SIDE*SIDE, link, links)
  }

  /**
   * Prints the links between each nodes. Used for debugging only
   */
  def printAL() = {
    for (node <- 0 to NODES) {
      System.out.print("Node %3d linked to nodes: ".format(node))
      for (neighbor <- 0 to dl(node)) {
        System.out.print("%3d ".format(al(node)(neighbor)))
      }
      System.out.println()
    }
    System.out.println()
  }

  /**
   * Print 3D layers nodes number
   * */
  def printLayers(sideNode: Int) = {
    for (layer <- 0 to sideNode) {
      System.out.println("Layer: " + layer)
      for (row <- 0 to sideNode) {
        for (col <- 0 to sideNode) {
          var current = layer + (col * sideNode) + (row * sideNode * sideNode)
          System.out.print("%3d ".format(current))
        }
        System.out.println()
      }
      System.out.println()
    }
  }
}